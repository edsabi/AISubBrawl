


<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>Sub Brawl Command</title>
<style>
:root{--bg:#020b16;--fg:#d8e4ee;--muted:#8ea3b7;--accent:#1e90ff;--panel:#071425;--card:#0c1a2b;}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--fg);font-family:ui-monospace,monospace;display:flex;flex-direction:column;height:100vh}
header{background:#041120;padding:8px 10px}
header .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
input,select,button{height:34px;border-radius:7px;border:1px solid #2c3f57;background:#0e1b2a;color:#fff;padding:0 10px}
button{background:#123a66;border-color:#2c3f57;cursor:pointer}
button.primary{background:var(--accent);border-color:#2c3f57}
button.ghost{background:#0e1b2a}
#mapWrap{position:relative}
canvas{background:#000;width:100%;height:54vh;touch-action:none;display:block}
#mapUI{position:absolute;top:8px;right:8px;display:flex;flex-direction:column;gap:6px;align-items:flex-end}
#mapUI button{width:38px;height:38px;padding:0}
#mapUI .pad{display:grid;grid-template-columns:38px 38px 38px;gap:6px;justify-content:center}
#tabbar{display:flex;gap:8px;background:#061327;border-top:1px solid #132743;padding:6px}
.tab{flex:1;text-align:center;padding:8px 0;border-radius:8px;background:#0b1930;border:1px solid #1b2f4a;color:#bcd0e4}
.tab.active{background:#173258;color:#fff}
#pages{flex:1;overflow:auto;background:var(--panel)}
.page{display:none;padding:10px}
.page.active{display:block}
.section{background:var(--card);border:1px solid #163150;border-radius:10px;padding:10px;margin-bottom:10px}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.label{color:var(--muted);font-size:.9em}
.small{font-size:.85em;color:#b8c7d6}
.list{font-size:.9em;line-height:1.4em}
hr{border:none;border-top:1px solid #17314f;margin:10px 0}
kbd{background:#0e1b2a;border:1px solid #2c3f57;border-bottom-width:2px;padding:1px 5px;border-radius:5px}
@media(max-width:700px){canvas{height:48vh}}
</style>
</head>
<body>

<header>
  <div class="row">
    <input id="username" placeholder="username" style="width:110px">
    <input id="password" type="password" placeholder="password" style="width:110px">
    <button class="primary" onclick="signup()">Sign up</button>
    <button onclick="login()">Login</button>
    <button onclick="spawn()">Spawn</button>
    <select id="subSelect" onchange="onSelectSub()" style="min-width:180px"><option value="">Select sub...</option></select>
    <span class="small" id="hudMini">‚Äî</span>
  </div>
</header>

<div id="mapWrap">
  <canvas id="map"></canvas>

  <!-- Map UI: zoom/pan + grid toggles -->
  <div id="mapUI">
    <div class="row" style="gap:6px">
      <label class="small" style="background:#0e1b2a;padding:4px 6px;border-radius:6px;border:1px solid #2c3f57">
        <input id="showGrid" type="checkbox" checked> Grid
      </label>
      <label class="small" style="background:#0e1b2a;padding:4px 6px;border-radius:6px;border:1px solid #2c3f57">
        <input id="showGridLabels" type="checkbox" checked> Labels
      </label>
    </div>
    <div class="pad">
      <div></div>
      <button class="ghost" onclick="panMap(0,-150)">‚Üë</button>
      <div></div>
      <button class="ghost" onclick="panMap(-150,0)">‚Üê</button>
      <button class="ghost" onclick="centerOnMe()">‚óé</button>
      <button class="ghost" onclick="panMap(150,0)">‚Üí</button>
      <div></div>
      <button class="ghost" onclick="panMap(0,150)">‚Üì</button>
      <div></div>
      <button class="ghost" onclick="resetView()" title="Reset">‚ü≤</button>
      <button class="ghost" onclick="zoomMap(1.2)">Ôºã</button>
      <button class="ghost" onclick="zoomMap(1/1.2)">Ôºç</button>
    </div>
    <label class="small">Zoom: <span id="zoomRead">1.00</span>√ó</label>
  </div>
</div>

<!-- Tabs -->
<div id="tabbar">
  <div class="tab active" data-page="maneuver">Maneuvering</div>
  <div class="tab" data-page="sonar">Sonar</div>
  <div class="tab" data-page="torps">Torpedoes</div>
</div>

<!-- Pages -->
<div id="pages">
  <!-- Maneuvering Page -->
  <div class="page active" id="maneuver">
    <div class="grid2">
      <div class="section">
        <div class="label">Propulsion & Depth</div>
        <div class="row" style="margin-top:6px">
          <input id="throttle" placeholder="throttle 0..1" style="width:120px">
          <button onclick="applyThrottle()">Set</button>
          <button onclick="quickThr(0)">Stop</button>
          <button onclick="quickThr(0.25)">¬º</button>
          <button onclick="quickThr(0.5)">¬Ω</button>
          <button onclick="quickThr(0.75)">¬æ</button>
          <button onclick="quickThr(1.0)">Full</button>
        </div>
        <div class="row" style="margin-top:6px">
          <input id="depthTarget" placeholder="target depth (m)" style="width:140px">
          <button onclick="setDepth()">Set Depth</button>
          <button onclick="clearHold()">Clear</button>
          <button onclick="snorkel(true)">Snorkel</button>
          <button onclick="snorkel(false)">Dive</button>
          <button onclick="emergencyBlow()">Blow</button>
        </div>
      </div>

      <div class="section">
        <div class="label">Helm</div>
        <div class="row" style="margin-top:6px">
          <input id="rudder" placeholder="rudder deg (-30..30)" style="width:170px">
          <button onclick="setRudder()">Set</button>
          <!-- Left should send +5 (CCW) -->
          <button onclick="rudderNudge(+5)">‚ü≤ Left +5</button>
          <!-- Right should send -5 (CW) -->
          <button onclick="rudderNudge(-5)">‚ü≥ Right -5</button>
        </div>
        <div class="row" style="margin-top:6px">
          <input id="planes" placeholder="planes -1..1" style="width:150px">
          <button onclick="setPlanes()">Set</button>
          <span class="small">Tip: planes ‚âà 0 enables depth-hold autopilot</span>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="label">Status</div>
      <div id="hud" class="list">‚Äî</div>
    </div>
  </div>

  <!-- Sonar Page -->
  <div class="page" id="sonar">
    <div class="grid2">
      <div class="section">
        <div class="label">Active Sonar</div>
        <div class="row" style="margin-top:6px">
          <input id="pingBearing" placeholder="az rel (¬∞)" style="width:110px">
          <input id="pingBeam" placeholder="beam (¬∞)" style="width:100px" value="25" max="210">
          <input id="pingRange" placeholder="range (m)" style="width:120px" value="4000" max="6000">
          <button class="primary" onclick="activePing()">Ping</button>
          <label class="small" style="margin-left:6px"><input id="showEchoes" type="checkbox" checked> show echoes</label>
        </div>
        <div class="small" style="margin-top:4px">Battery cost: <span id="pingBatteryCost">1.1</span>% | Max beam: 210¬∞ | Max range: 6000m</div>
        <hr/>
        <div class="label">Recent Echoes</div>
        <div id="echoList" class="list">‚Äî</div>
      </div>

      <div class="section">
        <div class="label">Passive Sonar</div>
        <div class="row" style="margin-top:6px">
          <input id="passiveDir" placeholder="array dir (¬∞ rel bow)" style="width:170px">
          <button onclick="setPassiveDir()">Set</button>
          <label class="small" style="margin-left:6px"><input id="passiveMulti" type="checkbox" checked> multi-bearing</label>
        </div>
        <hr/>
        <div class="label">Recent Bearings</div>
        <div id="passiveList" class="list">‚Äî</div>
        <div class="small" style="margin-top:4px; color:#888;">
          üö¢ submarine ‚Ä¢ üöÄ torpedo ‚Ä¢ üì° ping<br>
          <span style="color:#ffaa33">‚ñ†</span> sub 
          <span style="color:#ff4444">‚ñ†</span> torp 
          <span style="color:#44ff44">‚ñ†</span> ping
        </div>
      </div>
    </div>
  </div>

  <!-- Torpedoes Page -->
  <div class="page" id="torps">
    <div class="section">
      <div class="label">Launch</div>
      <div class="row" style="margin-top:6px">
        <input id="torpRange" placeholder="range (m)" value="600" max="6000" style="width:160px">
        <input id="tubeIdx" placeholder="tube (-2..2)" value="0" style="width:140px">
        <button class="primary" onclick="launchTorp()">Launch Torpedo</button>
      </div>
      <div class="small" style="margin-top:4px">Battery cost: <span id="batteryCost">8.0</span>%</div>
    </div>

    <div class="section">
      <div class="label">Your Torpedoes</div>
      <div id="torpList" class="list">‚Äî</div>
    </div>

    <div class="section">
      <div class="label">Torpedo Control</div>
      <div class="row" style="margin-top:6px">
        <select id="torpSelect" onchange="onSelectTorp()" style="min-width:280px">
          <option value="">Select torpedo...</option>
        </select>
      </div>
    </div>

    <div class="section">
      <div class="label">Movement Commands</div>
      <div class="row" style="margin-top:6px">
        <input id="torpSpeed" placeholder="speed (8-18)" style="width:120px">
        <button onclick="torpSetSpeed()">Set Speed</button>
      </div>
      <div class="row" style="margin-top:6px">
        <input id="torpTurn" placeholder="turn deg (¬±)" style="width:150px">
        <button onclick="torpTurn()">Apply Turn</button>
        <input id="torpHead" placeholder="heading deg (abs)" style="width:170px">
        <button onclick="torpSetHeading()">Set Heading</button>
      </div>
      <div class="row" style="margin-top:6px">
        <div class="label" style="font-size:12px">Quick Turns:</div>
        <button onclick="quickTurn(30)" style="width:50px">L30</button>
        <button onclick="quickTurn(15)" style="width:50px">L15</button>
        <button onclick="quickTurn(5)" style="width:40px">L5</button>
        <button onclick="quickTurn(-5)" style="width:40px">R5</button>
        <button onclick="quickTurn(-15)" style="width:50px">R15</button>
        <button onclick="quickTurn(-30)" style="width:50px">R30</button>
      </div>
      <div class="row" style="margin-top:6px">
        <input id="torpDepth" placeholder="depth m" style="width:150px">
        <button onclick="torpSetDepth()">Set Depth</button>
        <button onclick="detonateTorp()" style="background:#b22222;color:#fff">Detonate</button>
      </div>
    </div>

    <div class="section">
      <div class="label">Torpedo Sonar</div>
      <div class="row" style="margin-top:6px">
        <div class="label" style="font-size:12px">Active Ping:</div>
        <input id="torpPingRange" placeholder="range m" value="800" style="width:120px">
        <button onclick="torpPing()">Ping</button>
        <button id="torpPingToggle" onclick="torpPingToggle()">Auto: OFF</button>
      </div>
      <div class="small" style="margin-top:4px">
        Torpedo sonar: 2000m passive range, 1500m active range (30¬∞ beam)<br>
        Lower speeds = harder to detect by enemy sonar
      </div>
      <hr/>
      <div class="label">Torpedo Sonar Contacts</div>
      <div id="torpSonarList" class="list">‚Äî</div>
      <div class="small" style="margin-top:4px; color:#888;">
        üéØ torpedo detected submarine
      </div>
      <hr/>
      <div class="label">Torpedo Ping Results</div>
      <div id="torpPingList" class="list">‚Äî</div>
      <div class="small" style="margin-top:4px; color:#888;">
        üì° active ping contacts (range/bearing/depth)
      </div>
    </div>
  </div>
</div>

<script>
/* ---------- State & helpers ---------- */
const $=id=>document.getElementById(id);
const API_BASE='';
let API=null, selected=null, selectedTorp=null;
let subs=[], torps=[];
let lastEchoes=[], passiveContacts=[], torpPingContacts=[];
const ECHO_TTL=20, PASSIVE_TTL=12;
const DPR = window.devicePixelRatio||1;

const auth=()=>({'Authorization':'Bearer '+(API||'')});
function compassDeg(rad){ let d=(rad*180/Math.PI + 90)%360; if(d<0)d+=360; return d; }

function updateTorpSelect(){
  const sel = $('torpSelect');
  sel.innerHTML = '<option value="">Select torpedo...</option>';
  torps.forEach(t => {
    const opt = document.createElement('option');
    opt.value = t.id;
    opt.textContent = `${t.id.slice(0,6)} - Speed: ${t.speed?.toFixed(1) || 'N/A'} m/s - Depth: ${t.depth?.toFixed(0) || 'N/A'}m`;
    sel.appendChild(opt);
  });
}

function onSelectTorp(){
  selectedTorp = $('torpSelect').value || null;
  renderTorpSonarList();
  renderTorpPingList();
  
  // Update ping toggle button state
  const torp = torps.find(t => t.id === selectedTorp);
  if(torp) {
    updateTorpPingToggleButton(torp.active_sonar_enabled || false);
  }
}

/* ---------- Tabs ---------- */
[...document.querySelectorAll('#tabbar .tab')].forEach(t=>{
  t.addEventListener('click', ()=>{
    document.querySelectorAll('#tabbar .tab').forEach(x=>x.classList.remove('active'));
    document.querySelectorAll('#pages .page').forEach(x=>x.classList.remove('active'));
    t.classList.add('active');
    document.getElementById(t.dataset.page).classList.add('active');
  });
});

/* ---------- Signup/Login/Spawn ---------- */
async function signup(){
  const u=$('username').value,p=$('password').value;
  const r=await fetch(API_BASE+'/signup',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({username:u,password:p})});
  const j=await r.json(); if(!j.ok) return alert(j.error);
  API=j.api_key; connectStream(); alert('Signed up');
}
async function login(){
  const u=$('username').value,p=$('password').value;
  const r=await fetch(API_BASE+'/login',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({username:u,password:p})});
  const j=await r.json(); if(!j.ok) return alert(j.error);
  API=j.api_key; connectStream(); alert('Logged in');
}
async function spawn(){
  const r=await fetch(API_BASE+'/register_sub',{method:'POST',headers:{...auth()}});
  const j=await r.json(); if(!j.ok) return alert(j.error);
  selected=j.sub_id; updateSubSelect(); $('subSelect').value=selected; alert('Spawned '+selected.slice(0,8));
}

/* ---------- Sub select ---------- */
function updateSubSelect(){
  const sel=$('subSelect'), keep=sel.value;
  sel.innerHTML='<option value="">Select sub...</option>';
  subs.forEach(s=>{
    const o=document.createElement('option');
    o.value=s.id; o.textContent=`${s.id.slice(0,6)} ‚Äî d:${s.depth.toFixed(0)}m`;
    if(s.id===keep) o.selected=true;
    sel.appendChild(o);
  });
  if(!selected && subs.length){ selected=subs[0].id; sel.value=selected; }
}
function onSelectSub(){ selected=$('subSelect').value||null; }

/* ---------- Maneuvering actions ---------- */
async function applyThrottle(){ const t=parseFloat($('throttle').value||'0'); await fetch(`/control/${selected}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({throttle:t})});}
function quickThr(v){$('throttle').value=v; applyThrottle();}
async function setRudder(){ const v=parseFloat($('rudder').value||'0'); await fetch(`/control/${selected}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({rudder_deg:v})});}
async function rudderNudge(d){ await fetch(`/control/${selected}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({rudder_nudge_deg:d})});}
async function setPlanes(){ const v=parseFloat($('planes').value||'0'); await fetch(`/control/${selected}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({planes:v})});}
async function setDepth(){ const d=parseFloat($('depthTarget').value||''); await fetch(`/control/${selected}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({target_depth:d})});}
async function clearHold(){ await fetch(`/control/${selected}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({target_depth:null})});}
async function snorkel(on){ await fetch(`/snorkel/${selected}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({on})});}
async function emergencyBlow(){ await fetch(`/emergency_blow/${selected}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'}});}

/* ---------- Sonar actions ---------- */
async function activePing(){
  const brg=parseFloat($('pingBearing').value||'0');
  const beam=parseFloat($('pingBeam').value||'25');
  const rng=parseFloat($('pingRange').value||'4000');
  await fetch(`/ping/${selected}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},
    body:JSON.stringify({center_bearing_deg:brg,beamwidth_deg:beam,max_range:rng})});
}
async function setPassiveDir(){
  const v=parseFloat($('passiveDir').value||'0');
  await fetch(`/set_passive_array/${selected}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({dir_deg:v})});
}

/* ---------- Torpedoes ---------- */
async function launchTorp(){
  const range=Math.min(parseFloat($('torpRange').value||'600'), 6000);
  const tube=parseInt($('tubeIdx').value||'0',10);
  const r=await fetch(`/launch_torpedo/${selected}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({range:range,tube})});
  const j=await r.json(); if(!j.ok) return alert(j.error); 
  selectedTorp = j.torpedo_id;
  updateTorpSelect();
  $('torpSelect').value = selectedTorp;
}

async function torpSetSpeed(){
  if(!selectedTorp){ alert('Select a torpedo first'); return; }
  const speed=parseFloat($('torpSpeed').value||'18');
  await fetch(`/set_torp_speed/${selectedTorp}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({speed})});
}

async function torpTurn(){
  if(!selectedTorp){ alert('Select a torpedo first'); return; }
  const turn=parseFloat($('torpTurn').value||'0');
  await fetch(`/set_torp_heading/${selectedTorp}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({turn_deg:turn,dt:1.0})});
}

async function torpSetHeading(){
  if(!selectedTorp){ alert('Select a torpedo first'); return; }
  const hdg=parseFloat($('torpHead').value||'0');
  await fetch(`/set_torp_heading/${selectedTorp}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({heading_deg:hdg,dt:1.0})});
}

async function quickTurn(degrees){
  if(!selectedTorp){ alert('Select a torpedo first'); return; }
  $('torpTurn').value = degrees;
  await fetch(`/set_torp_heading/${selectedTorp}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({turn_deg:degrees,dt:1.0})});
}

async function torpSetDepth(){
  if(!selectedTorp){ alert('Select a torpedo first'); return; }
  const d=parseFloat($('torpDepth').value||'0');
  await fetch(`/set_torp_depth/${selectedTorp}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({depth:d})});
}

async function torpPing(){
  if(!selectedTorp){ alert('Select a torpedo first'); return; }
  const range=parseFloat($('torpPingRange').value||'800');
  const r=await fetch(`/torp_ping/${selectedTorp}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'},body:JSON.stringify({max_range:range})});
  const j=await r.json(); if(!j.ok) return alert(j.error||'ping failed');
  
  const now=performance.now()/1000;
  j.contacts.forEach(contact => {
    torpPingContacts.unshift({
      torpedo_id: selectedTorp,
      bearing: contact.bearing,
      range: contact.range,
      depth: contact.depth,
      time: now
    });
  });
  if(torpPingContacts.length>120) torpPingContacts.splice(120);
  renderTorpPingList();
}

async function torpPingToggle(){
  if(!selectedTorp){ alert('Select a torpedo first'); return; }
  const r=await fetch(`/torp_ping_toggle/${selectedTorp}`,{method:'POST',headers:{...auth(),'Content-Type':'application/json'}});
  const j=await r.json(); if(!j.ok) return alert(j.error||'toggle failed');
  updateTorpPingToggleButton(j.active_sonar_enabled);
}

function updateTorpPingToggleButton(enabled){
  const btn = $('torpPingToggle');
  if(btn) {
    btn.textContent = enabled ? 'Auto: ON' : 'Auto: OFF';
    btn.style.backgroundColor = enabled ? '#228B22' : '';
  }
}

async function detonateTorp(){
  if(!selectedTorp){ alert('Select a torpedo first'); return; }
  if(!confirm('Detonate torpedo '+selectedTorp.slice(0,8)+'?')) return;
  const r = await fetch('/detonate/' + selectedTorp, { method:'POST', headers:{...auth(),'Content-Type':'application/json'} });
  const j = await r.json(); if(!j.ok) return alert(j.error||'detonate failed'); 
  alert('Detonated ‚Äî affected: '+(j.affected||0));
  selectedTorp = null;
  updateTorpSelect();
}

/* ---------- Stream ---------- */
function connectStream(){
  const es=new EventSource('/stream?api_key='+API);
  es.addEventListener('snapshot', e=>{
    const d=JSON.parse(e.data); subs=d.subs||[]; torps=d.torpedoes||[];
    updateSubSelect(); updateTorpSelect(); renderMiniHUD(); renderEchoList(); renderPassiveList(); renderTorpList(); renderTorpSonarList(); renderTorpPingList();
  });
  es.addEventListener('echo', e=>{
    const d=JSON.parse(e.data); d.time=performance.now()/1000;
    lastEchoes.unshift(d); if(lastEchoes.length>80) lastEchoes.pop();
    renderEchoList();
  });
  es.addEventListener('contact', e=>{
    const c=JSON.parse(e.data);
    if(c.type==='passive' || c.type==='active_ping_detected') {
      c.time=performance.now()/1000;
      if(c.type==='active_ping_detected') c.contact_type='ping';
      passiveContacts.unshift(c); if(passiveContacts.length>120) passiveContacts.pop();
      renderPassiveList();
    }
  });
  es.addEventListener('torpedo_contact', e=>{
    const c=JSON.parse(e.data);
    c.time=performance.now()/1000;
    // Add torpedo prefix to distinguish from sub contacts
    c.contact_type = 'torpedo_' + c.contact_type;
    passiveContacts.unshift(c); if(passiveContacts.length>120) passiveContacts.pop();
    renderPassiveList();
    renderTorpSonarList();
  });
  es.addEventListener('torpedo_ping', e=>{
    const d=JSON.parse(e.data);
    const now=performance.now()/1000;
    d.contacts.forEach(contact => {
      torpPingContacts.unshift({
        torpedo_id: d.torpedo_id,
        bearing: contact.bearing,
        range: contact.range,
        depth: contact.depth,
        time: now
      });
    });
    if(torpPingContacts.length>120) torpPingContacts.splice(120);
    renderTorpPingList();
  });
}

/* ---------- HUD text ---------- */
function renderMiniHUD(){
  const s=subs.find(z=>z.id===selected);
  $('hudMini').textContent = s ? `id ${s.id.slice(0,6)} | x ${s.x.toFixed(0)} y ${s.y.toFixed(0)} | d ${s.depth.toFixed(0)}m | spd ${s.speed.toFixed(1)} | bat ${s.battery.toFixed(0)}%` : '‚Äî';
}
function renderEchoList(){
  const now=performance.now()/1000;
  const rows=lastEchoes
    .filter(e=>e.observer_sub_id===selected && (now-e.time)<=ECHO_TTL)
    .slice(0,10)
    .map(e=>{
      const brg=(e.bearing*180/Math.PI).toFixed(0);
      const rng=Math.round(e.range);
      const dep=Math.round(e.estimated_depth);
      const q=Math.round((e.quality||0)*100);
      return `‚Ä¢ brg ${brg}¬∞  r ${rng}m  depth ~${dep}m  q ${q}%`;
    });
  $('echoList').innerHTML = rows.join('<br>') || '‚Äî';
}
function renderPassiveList(){
  const now=performance.now()/1000;
  const list = ($('passiveMulti')?.checked ?? true)
    ? passiveContacts.filter(c=>c.observer_sub_id===selected && (now-c.time)<=PASSIVE_TTL).slice(0,12)
    : passiveContacts.filter(c=>c.observer_sub_id===selected && (now-c.time)<=PASSIVE_TTL).slice(0,1);
  const rows=list.map(c=>{
    const brg=(c.bearing*180/Math.PI).toFixed(0);
    const relBrg = c.bearing_relative ? (c.bearing_relative*180/Math.PI).toFixed(0) : '?';
    const contactIcon = c.contact_type === 'torpedo' ? 'üöÄ' : 
                       c.contact_type === 'torpedo_submarine' ? 'üéØ' :
                       c.contact_type === 'ping' ? 'üì°' : 
                       c.contact_type === 'emergency_blow' ? 'üí®' : 'üö¢';
    const direction = Math.abs(parseFloat(relBrg)) < 45 ? 'ahead' :
                     Math.abs(parseFloat(relBrg)) > 135 ? 'astern' :
                     parseFloat(relBrg) > 0 ? 'starboard' : 'port';
    return `${contactIcon} ${direction} ${brg}¬∞ ${c.range_class}`;
  });
  $('passiveList').innerHTML = rows.join('<br>') || '‚Äî';
}

function renderTorpSonarList(){
  const now=performance.now()/1000;
  const torpContacts = passiveContacts.filter(c=>c.torpedo_id===selectedTorp && c.contact_type.startsWith('torpedo_') && (now-c.time)<=PASSIVE_TTL).slice(0,8);
  const rows=torpContacts.map(c=>{
    const brg=(c.bearing*180/Math.PI).toFixed(0);
    const relBrg = c.bearing_relative ? (c.bearing_relative*180/Math.PI).toFixed(0) : '?';
    const contactIcon = 'üéØ';
    const direction = Math.abs(parseFloat(relBrg)) < 45 ? 'ahead' :
                     Math.abs(parseFloat(relBrg)) > 135 ? 'astern' :
                     parseFloat(relBrg) > 0 ? 'starboard' : 'port';
    return `${contactIcon} ${direction} ${brg}¬∞ ${c.range_class}`;
  });
  $('torpSonarList').innerHTML = rows.join('<br>') || '‚Äî';
}

function renderTorpPingList(){
  const now=performance.now()/1000;
  const pingContacts = torpPingContacts.filter(c=>c.torpedo_id===selectedTorp && (now-c.time)<=PASSIVE_TTL).slice(0,8);
  const rows=pingContacts.map(c=>{
    const brg=(c.bearing*180/Math.PI).toFixed(0);
    const rng=Math.round(c.range);
    const dep=Math.round(c.depth);
    return `üì° ${brg}¬∞ ${rng}m d${dep}m`;
  });
  $('torpPingList').innerHTML = rows.join('<br>') || '‚Äî';
}

function renderTorpList(){
  const rows = (torps||[]).map(t=>{
    const hdg = (t.heading*180/Math.PI).toFixed(0);
    const cur = (t.depth ?? 0).toFixed(0);                   // CURRENT depth
    const tgt = (t.target_depth != null) ? `‚Üí${t.target_depth.toFixed(0)}` : '';
    const wl  = Math.round(t.wire_length ?? 0);
    const mode= t.mode || t.control_mode || 'wire';
    const x   = (t.x??0).toFixed(0), y=(t.y??0).toFixed(0);
    return `‚Ä¢ ${t.id.slice(0,6)}  x ${x} y ${y}  d ${cur}m${tgt}  hdg ${hdg}¬∞  ${mode}  range ${wl}m`;
  });
  $('torpList').innerHTML = rows.join('<br>') || '‚Äî';
}




/* ---------- Map / Canvas (WORLD ROTATED so 0¬∞=North) ---------- */
const canvas=$('map'), ctx=canvas.getContext('2d');
let viewport={x:0,y:0,zoom:0.15};
const DPRatio = window.devicePixelRatio||1;

function resize(){canvas.width=canvas.clientWidth*DPRatio;canvas.height=canvas.clientHeight*DPRatio;ctx.setTransform(DPRatio,0,0,DPRatio,0,0);}
window.addEventListener('resize', resize, {passive:true}); resize();

/* Rotate world by +90¬∞ in projection */
function worldToScreen(x, y){
  const cx = canvas.clientWidth/2, cy = canvas.clientHeight/2;
  const dx = x - viewport.x;
  const dy = y - viewport.y;
  const xr = -dy;           // R(œÄ/2)[dx,dy] = [-dy, dx]
  const yr =  dx;
  return [ cx + xr*viewport.zoom, cy - yr*viewport.zoom ];
}
function screenToWorld(sx, sy){
  const cx = canvas.clientWidth/2, cy = canvas.clientHeight/2;
  const xr = (sx - cx)/viewport.zoom;
  const yr = (cy - sy)/viewport.zoom;
  const dx =  yr;           // R(-œÄ/2)[xr,yr] = [yr, -xr]
  const dy = -xr;
  return [ dx + viewport.x, dy + viewport.y ];
}

function resetView(){
  viewport.x=0; viewport.y=0;
  viewport.zoom = Math.min(canvas.clientWidth,canvas.clientHeight)/(6000*2)*1.2;
}
function centerOnMe(){ const s=subs.find(z=>z.id===selected); if(!s) return; viewport.x=s.x; viewport.y=s.y; }
function zoomMap(f){
  const cx=canvas.clientWidth/2, cy=canvas.clientHeight/2;
  const [wx,wy]=screenToWorld(cx,cy);
  viewport.zoom*=f;
  const [wx2,wy2]=screenToWorld(cx,cy);
  viewport.x+=wx-wx2; viewport.y+=wy-wy2;
}
function panMap(dx,dy){ viewport.x -= dy/viewport.zoom; viewport.y -= dx/viewport.zoom; }

/* Grid helpers */
function niceStep(pxPerUnit, targetPx){
  const raw = targetPx / pxPerUnit;
  const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
  const norm = raw / pow10;
  let step;
  if (norm < 1.5) step = 1;
  else if (norm < 3.5) step = 2;
  else if (norm < 7.5) step = 5;
  else step = 10;
  return step * pow10;
}
function drawGrid(){
  if(!$('showGrid').checked) return;
  const [wx0, wy0] = screenToWorld(0, canvas.clientHeight);
  const [wx1, wy1] = screenToWorld(canvas.clientWidth, 0);
  const minX = Math.min(wx0, wx1), maxX = Math.max(wx0, wx1);
  const minY = Math.min(wy0, wy1), maxY = Math.max(wy0, wy1);

  const unitsPerPx = 1/viewport.zoom;
  const majorStep = niceStep(1/unitsPerPx, 160);
  const minorStep = majorStep/4;

  // Minor grid
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(80,120,160,0.25)';
  let startMinorX = Math.floor(minX/minorStep)*minorStep;
  let endMinorX   = Math.ceil (maxX/minorStep)*minorStep;
  for(let x=startMinorX; x<=endMinorX; x+=minorStep){
    const [sx0, sy0] = worldToScreen(x, minY);
    const [sx1, sy1] = worldToScreen(x, maxY);
    ctx.beginPath(); ctx.moveTo(sx0, sy0); ctx.lineTo(sx1, sy1); ctx.stroke();
  }
  let startMinorY = Math.floor(minY/minorStep)*minorStep;
  let endMinorY   = Math.ceil (maxY/minorStep)*minorStep;
  for(let y=startMinorY; y<=endMinorY; y+=minorStep){
    const [sx0, sy0] = worldToScreen(minX, y);
    const [sx1, sy1] = worldToScreen(maxX, y);
    ctx.beginPath(); ctx.moveTo(sx0, sy0); ctx.lineTo(sx1, sy1); ctx.stroke();
  }

  // Major grid
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = 'rgba(120,170,210,0.45)';
  let startMajorX = Math.floor(minX/majorStep)*majorStep;
  let endMajorX   = Math.ceil (maxX/majorStep)*majorStep;
  for(let x=startMajorX; x<=endMajorX; x+=majorStep){
    const [sx0, sy0] = worldToScreen(x, minY);
    const [sx1, sy1] = worldToScreen(x, maxY);
    ctx.beginPath(); ctx.moveTo(sx0, sy0); ctx.lineTo(sx1, sy1); ctx.stroke();
  }
  let startMajorY = Math.floor(minY/majorStep)*majorStep;
  let endMajorY   = Math.ceil (maxY/majorStep)*majorStep;
  for(let y=startMajorY; y<=endMajorY; y+=majorStep){
    const [sx0, sy0] = worldToScreen(minX, y);
    const [sx1, sy1] = worldToScreen(maxX, y);
    ctx.beginPath(); ctx.moveTo(sx0, sy0); ctx.lineTo(sx1, sy1); ctx.stroke();
  }

  // Labels
  if($('showGridLabels').checked){
    ctx.fillStyle = '#9fc3e6';
    ctx.font = '12px ui-monospace';
    for(let x=startMajorX; x<=endMajorX; x+=majorStep){
      const [sx, sy] = worldToScreen(x, maxY);
      ctx.fillText(`X ${Math.round(x)}`, sx+4, sy+14);
    }
    for(let y=startMajorY; y<=endMajorY; y+=majorStep){
      const [sx, sy] = worldToScreen(minX, y);
      ctx.fillText(`Y ${Math.round(y)}`, sx+6, sy-6);
    }
  }
}

/* draw fan in WORLD coords */
function drawFanWorld(cx,cy,center_world,beam_deg,range_m,color,alpha){
  const half=(beam_deg*Math.PI/180)/2;
  const pts=[];
  for(let i=-half;i<=half;i+=Math.max(half/9,0.02)){
    const a=center_world+i;
    const wx=cx+Math.cos(a)*range_m;
    const wy=cy+Math.sin(a)*range_m;
    pts.push(worldToScreen(wx,wy));
  }
  const [sx,sy]=worldToScreen(cx,cy);
  ctx.save();ctx.globalAlpha=alpha;ctx.fillStyle=color;
  ctx.beginPath();ctx.moveTo(sx,sy);
  pts.forEach(([px,py])=>ctx.lineTo(px,py));
  ctx.closePath();ctx.fill();ctx.restore();
}

/* mouse drag / wheel pan-zoom */
let pan=false, last=[0,0];
canvas.addEventListener('pointerdown',e=>{pan=true; last=[e.clientX,e.clientY]; canvas.setPointerCapture(e.pointerId);});
canvas.addEventListener('pointermove',e=>{ if(!pan) return; const dx=e.clientX-last[0], dy=e.clientY-last[1]; panMap(-dx,-dy); last=[e.clientX,e.clientY];});
canvas.addEventListener('pointerup',()=>{pan=false;});
canvas.addEventListener('wheel',e=>{
  e.preventDefault();
  const factor=Math.exp(-e.deltaY*0.001);
  const [wx,wy]=screenToWorld(e.offsetX,e.offsetY);
  viewport.zoom*=factor;
  const [wx2,wy2]=screenToWorld(e.offsetX,e.offsetY);
  viewport.x+=wx-wx2; viewport.y+=wy-wy2;
},{passive:false});

function draw(){
  ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
  $('zoomRead').textContent = viewport.zoom.toFixed(2);

  drawGrid(); // grid first

  // arena ring (world radius 6000)
  ctx.strokeStyle='#1a314b'; ctx.lineWidth=2;
  const [rx,ry]=worldToScreen(0,0); ctx.beginPath(); ctx.arc(rx,ry,6000*viewport.zoom,0,Math.PI*2); ctx.stroke();

  // subs (bow points true direction, world rotated projection)
  subs.forEach(s=>{
    const [sx,sy]=worldToScreen(s.x,s.y);
    ctx.save(); ctx.translate(sx,sy);
    ctx.rotate(-s.heading + Math.PI/2 + Math.PI);  // flipped triangle, 0¬∞=North
    ctx.fillStyle=(s.id===selected)?'#5fd9ff':'#6c7f94';
    ctx.beginPath(); ctx.moveTo(12,0); ctx.lineTo(-10,6); ctx.lineTo(-10,-6); ctx.closePath(); ctx.fill();
    ctx.restore();

    // label with depth and coordinates
    ctx.fillStyle='#a8bfd6'; ctx.font='12px ui-monospace';
    ctx.fillText(`${s.id.slice(0,4)} d:${s.depth.toFixed(0)} x:${s.x.toFixed(0)} y:${s.y.toFixed(0)}`, sx+10, sy-10);
  });


// torpedoes + labels (show current and target if available)
torps.forEach(t=>{
  const [tx,ty] = worldToScreen(t.x, t.y);

  // pick CURRENT depth (prefer current_depth, else depth)
  const cur = (t.current_depth != null ? t.current_depth : t.depth) ?? 0;
  const tgt = (t.target_depth != null ? t.target_depth : null);

  ctx.fillStyle = '#ffbb33';
  ctx.beginPath(); ctx.arc(tx,ty,4,0,Math.PI*2); ctx.fill();

  ctx.fillStyle = '#ffd28a';
  ctx.font = '12px ui-monospace';
  let label = `d:${cur.toFixed(0)}m`;
  if (tgt != null && Math.abs(tgt - cur) > 0.5) {
    label += `‚Üí${tgt.toFixed(0)}`;   // show target if different
  }
  label += ` x:${(t.x??0).toFixed(0)} y:${(t.y??0).toFixed(0)}`;
  ctx.fillText(label, tx+6, ty-6);
});

// torpedo sonar contacts for all owned torpedoes
if($('showEchoes')?.checked){
  const now=performance.now()/1000;
  const myTorps = torps.filter(t => subs.some(s => s.id === selected && s.owner_id)); // torpedoes from my subs
  
  myTorps.forEach(torp => {
    // Active ping contacts (green circles)
    const pingContacts = torpPingContacts.filter(c=>c.torpedo_id===torp.id && (now-c.time)<=PASSIVE_TTL);
    pingContacts.forEach(contact => {
      const contactX = torp.x + Math.cos(contact.bearing) * contact.range;
      const contactY = torp.y + Math.sin(contact.bearing) * contact.range;
      const [cx, cy] = worldToScreen(contactX, contactY);
      
      ctx.fillStyle = '#00ff00';
      ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); ctx.stroke();
      
      ctx.fillStyle = '#ffffff';
      ctx.font = '10px ui-monospace';
      ctx.fillText(`${Math.round(contact.range)}m`, cx+8, cy-8);
    });
    
    // Passive sonar contacts (orange bearing lines)
    const passiveContacts = passiveContacts.filter(c=>c.torpedo_id===torp.id && c.contact_type.startsWith('torpedo_') && (now-c.time)<=PASSIVE_TTL);
    passiveContacts.forEach(contact => {
      const [tx, ty] = worldToScreen(torp.x, torp.y);
      const endX = torp.x + Math.cos(contact.bearing) * 2000;
      const endY = torp.y + Math.sin(contact.bearing) * 2000;
      const [ex, ey] = worldToScreen(endX, endY);
      
      ctx.strokeStyle = '#ffaa00';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(tx, ty);
      ctx.lineTo(ex, ey);
      ctx.stroke();
      ctx.setLineDash([]);
    });
  });
}



  // active echoes & beam
  const now=performance.now()/1000;
  if(selected && $('showEchoes').checked){
    const me=subs.find(z=>z.id===selected);
    if(me){
      const beam=parseFloat($('pingBeam').value||'25');
      const brg=parseFloat($('pingBearing').value||'0');
      const maxR=parseFloat($('pingRange').value||'4000');
      const centerWorld = me.heading + (brg*Math.PI/180);
      drawFanWorld(me.x, me.y, centerWorld, beam, maxR, '#4dd9ff', 0.12);

      lastEchoes.forEach(e=>{
        if(e.observer_sub_id!==selected) return;
        const age=now-e.time; if(age>ECHO_TTL) return;
        const alpha=Math.max(0.15,1-age/ECHO_TTL)*(e.quality??1);
        const wx=me.x + Math.cos(e.bearing)*e.range;
        const wy=me.y + Math.sin(e.bearing)*e.range;
        const [ex,ey]=worldToScreen(wx,wy);
        ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle='#4dd9ff';
        ctx.beginPath(); ctx.arc(ex,ey,5,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#cfe3f5'; ctx.font='12px ui-monospace';
        ctx.fillText(`${Math.round(e.range)}m ~${Math.round(e.estimated_depth)}m`, ex+8, ey-8);
        ctx.restore();
      });
    }
  }

  // passive bearings
  if(selected){
    const me=subs.find(z=>z.id===selected);
    if(me){
      const multi = $('passiveMulti')?.checked ?? true;
      const recent = passiveContacts.filter(p=>p.observer_sub_id===selected && (now-p.time)<=PASSIVE_TTL);
      const list = multi ? recent : recent.slice(0,1);
      const [sx,sy]=worldToScreen(me.x,me.y);
      list.forEach(p=>{
        const len = (p.range_class==='short'?1200:p.range_class==='medium'?2400:4000);
        const wx = me.x + Math.cos(p.bearing)*len;
        const wy = me.y + Math.sin(p.bearing)*len;
        const [ex,ey]=worldToScreen(wx,wy);
        const age=now-p.time, alpha=Math.max(0.2,1-age/PASSIVE_TTL);
        
        // Different colors for different contact types
        let color = '#ffaa33'; // default submarine
        if(p.contact_type === 'torpedo') color = '#ff4444';
        if(p.contact_type === 'ping') color = '#44ff44';
        if(p.contact_type === 'emergency_blow') color = '#ff8800';
        
        ctx.save(); ctx.globalAlpha=alpha; ctx.strokeStyle=color; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(ex,ey); ctx.stroke(); ctx.restore();
      });
    }
  }

  requestAnimationFrame(draw);
}
resetView(); requestAnimationFrame(draw);

/* ---------- Periodic HUD ---------- */
setInterval(()=>{
  const s=subs.find(z=>z.id===selected);
  if(!s){ $('hud').innerHTML='‚Äî'; $('hudMini').textContent='‚Äî'; return; }
  $('hud').innerHTML =
    `id <kbd>${s.id.slice(0,8)}</kbd><br>`+
    `pos X ${s.x.toFixed(1)} m  Y ${s.y.toFixed(1)} m<br>`+
    `depth ${s.depth.toFixed(1)} m | target ${s.target_depth==null?'‚Äî':s.target_depth.toFixed(0)} m<br>`+
    `heading ${compassDeg(s.heading).toFixed(0)}¬∞ | pitch ${(s.pitch*180/Math.PI).toFixed(1)}¬∞ | rudder ${(s.rudder_angle*180/Math.PI).toFixed(1)}¬∞<br>`+
    `speed ${s.speed.toFixed(2)} m/s | throttle ${(s.throttle*100).toFixed(0)}%<br>`+
    `battery ${s.battery.toFixed(1)}% | snorkel ${s.is_snorkeling?'ON':'off'} | blow ${Math.round(s.blow_charge*100)}%<br>`+
    `health ${s.health.toFixed(0)}%`;
  renderMiniHUD();
  
  // Update torpedo battery cost
  const range = parseFloat($('torpRange')?.value || '600');
  const cost = (range / 100) * 1.33;
  if($('batteryCost')) $('batteryCost').textContent = cost.toFixed(1);
  
  // Update ping battery cost
  const pingBeam = parseFloat($('pingBeam')?.value || '25');
  const pingRange = parseFloat($('pingRange')?.value || '4000');
  const pingCost = 0.5 + (pingBeam * 0.04) + ((pingRange / 100) * 0.2683);
  if($('pingBatteryCost')) $('pingBatteryCost').textContent = pingCost.toFixed(1);
}, 1000);

// Update ping battery cost when inputs change
function updatePingBatteryCost() {
  const pingBeam = parseFloat($('pingBeam')?.value || '25');
  const pingRange = parseFloat($('pingRange')?.value || '4000');
  const pingCost = 0.5 + (pingBeam * 0.04) + ((pingRange / 100) * 0.2683);
  if($('pingBatteryCost')) $('pingBatteryCost').textContent = pingCost.toFixed(1);
}

$('pingBeam')?.addEventListener('input', updatePingBatteryCost);
$('pingRange')?.addEventListener('input', updatePingBatteryCost);
</script>
</body>
</html>

